a:175:{i:0;a:3:{i:0;s:14:"document_start";i:1;a:0:{}i:2;i:0;}i:1;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:22:"Dependencies Injection";i:1;i:1;i:2;i:1;}i:2;i:1;}i:2;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:1;}i:2;i:1;}i:3;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:39;}i:4;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:12:"1.Definition";i:1;i:2;i:2;i:39;}i:2;i:39;}i:5;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:2;}i:2;i:39;}i:6;a:3:{i:0;s:10:"quote_open";i:1;a:0:{}i:2;i:63;}i:7;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:115:" Dependency injection is a software design pattern that implements inversion of control for resolving dependencies.";}i:2;i:65;}i:8;a:3:{i:0;s:11:"quote_close";i:1;a:0:{}i:2;i:180;}i:9;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:180;}i:10;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:86:"Dependency injection means giving an object its instance variables. Really. That's it.";}i:2;i:181;}i:11;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:267;}i:12;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:267;}i:13;a:3:{i:0;s:14:"underline_open";i:1;a:0:{}i:2;i:269;}i:14;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:4:"Note";}i:2;i:271;}i:15;a:3:{i:0;s:15:"underline_close";i:1;a:0:{}i:2;i:275;}i:16;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:165:": DI là phương pháp viết code đưa các dependency vào class thông qua constructor hoặc setter, không phải khởi tạo trực tiếp bên trong class.";}i:2;i:277;}i:17;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:442;}i:18;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:444;}i:19;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:42:"1.1 Ưu điểm của Dependency Injection";i:1;i:3;i:2;i:444;}i:2;i:444;}i:20;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:3;}i:2;i:444;}i:21;a:3:{i:0;s:10:"listu_open";i:1;a:0:{}i:2;i:496;}i:22;a:3:{i:0;s:13:"listitem_open";i:1;a:1:{i:0;i:1;}i:2;i:496;}i:23;a:3:{i:0;s:16:"listcontent_open";i:1;a:0:{}i:2;i:496;}i:24;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:39:" Tách ra các thành phần liên quan";}i:2;i:500;}i:25;a:3:{i:0;s:17:"listcontent_close";i:1;a:0:{}i:2;i:539;}i:26;a:3:{i:0;s:14:"listitem_close";i:1;a:0:{}i:2;i:539;}i:27;a:3:{i:0;s:13:"listitem_open";i:1;a:1:{i:0;i:1;}i:2;i:539;}i:28;a:3:{i:0;s:16:"listcontent_open";i:1;a:0:{}i:2;i:539;}i:29;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:117:" Giảm code trong application class, tất cả việc khởi tạo dependency được tạo ra bởi các injector";}i:2;i:543;}i:30;a:3:{i:0;s:17:"listcontent_close";i:1;a:0:{}i:2;i:660;}i:31;a:3:{i:0;s:14:"listitem_close";i:1;a:0:{}i:2;i:660;}i:32;a:3:{i:0;s:13:"listitem_open";i:1;a:1:{i:0;i:1;}i:2;i:660;}i:33;a:3:{i:0;s:16:"listcontent_open";i:1;a:0:{}i:2;i:660;}i:34;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:36:" Ứng dụng dễ dàng mở rộng";}i:2;i:664;}i:35;a:3:{i:0;s:17:"listcontent_close";i:1;a:0:{}i:2;i:700;}i:36;a:3:{i:0;s:14:"listitem_close";i:1;a:0:{}i:2;i:700;}i:37;a:3:{i:0;s:13:"listitem_open";i:1;a:1:{i:0;i:1;}i:2;i:700;}i:38;a:3:{i:0;s:16:"listcontent_open";i:1;a:0:{}i:2;i:700;}i:39;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:49:" Có thể viết Unit test cho cả ứng dụng";}i:2;i:704;}i:40;a:3:{i:0;s:17:"listcontent_close";i:1;a:0:{}i:2;i:753;}i:41;a:3:{i:0;s:14:"listitem_close";i:1;a:0:{}i:2;i:753;}i:42;a:3:{i:0;s:11:"listu_close";i:1;a:0:{}i:2;i:753;}i:43;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:755;}i:44;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:20:"1.2 Nhược điểm";i:1;i:3;i:2;i:755;}i:2;i:755;}i:45;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:3;}i:2;i:755;}i:46;a:3:{i:0;s:10:"listu_open";i:1;a:0:{}i:2;i:785;}i:47;a:3:{i:0;s:13:"listitem_open";i:1;a:1:{i:0;i:1;}i:2;i:785;}i:48;a:3:{i:0;s:16:"listcontent_open";i:1;a:0:{}i:2;i:785;}i:49;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:98:" Khi khởi tạo 1 đối tượng bạn phải biết các dependency nào được sử dụng.";}i:2;i:789;}i:50;a:3:{i:0;s:17:"listcontent_close";i:1;a:0:{}i:2;i:887;}i:51;a:3:{i:0;s:14:"listitem_close";i:1;a:0:{}i:2;i:887;}i:52;a:3:{i:0;s:11:"listu_close";i:1;a:0:{}i:2;i:887;}i:53;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:887;}i:54;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:2:"  ";}i:2;i:888;}i:55;a:3:{i:0;s:6:"entity";i:1;a:1:{i:0;s:3:"...";}i:2;i:890;}i:56;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:893;}i:57;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:895;}i:58;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:8:"2. Usage";i:1;i:2;i:2;i:895;}i:2;i:895;}i:59;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:2;}i:2;i:895;}i:60;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:917;}i:61;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:11:"2.1 Example";i:1;i:3;i:2;i:917;}i:2;i:917;}i:62;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:3;}i:2;i:917;}i:63;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:917;}i:64;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:29:"Ví dụ khi không dùng DI ";}i:2;i:940;}i:65;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:975;}i:66;a:3:{i:0;s:4:"code";i:1;a:3:{i:0;s:801:"
// Example about developer does not use dependency injection
class Person {
	public function __construct($fullname, $address) {
		$this->fullname = $fullname;
		$this->address = $address;
	}
	public function setFullName($fullname) {
		$this->fullname = $fullname;
	}
	public function setAddress($address) {
		$this->address = $address;
	}
	public function getFullName() {
		return $this->fullname;
	}
	public function getAddress() {
		return $this->address;
	}
}

class Student extends Person {
	public function __construct($fullname, $address) {
		$this->student = new Person($fullname, $address);
	}
	public function getStudentName() {
		return strtoupper($this->student->fullname);
	}
	public function getStudentInfo() {
		return strtoupper($this->student->fullname.$this->student->address);
	}
}
";i:1;s:3:"php";i:2;N;}i:2;i:975;}i:67;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:975;}i:68;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:131:"Vấn đề đặt ra: Khi ta muốn thêm 1 object gender trong class Person ta phải thay đổi 2 class là Person và Student ";}i:2;i:1790;}i:69;a:3:{i:0;s:6:"entity";i:1;a:1:{i:0;s:2:"->";}i:2;i:1921;}i:70;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:28:" code maintain không tốt.";}i:2;i:1923;}i:71;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:1951;}i:72;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:1951;}i:73;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:139:"Giải pháp : Sử dụng DI, ta thêm object gender trong class Person, class Student vẫn có thể sử dụng được object gender.";}i:2;i:1953;}i:74;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:2092;}i:75;a:3:{i:0;s:4:"code";i:1;a:3:{i:0;s:970:"
class Person {
	public function __construct($fullname, $address, $gender) {
		$this->fullname = $fullname;
		$this->address = $address;
                $this->gender = $gender;
	}
	public function setFullName($fullname) {
		$this->fullname = $fullname;
	}
	public function setAddress($address) {
		$this->address = $address;
	}
	public function getFullName() {
		return $this->fullname;
	}
	public function getAddress() {
		return $this->address;
	}
}

class Student extends Person {
    public function __construct(Person $person) {
        $this->student = $person;
    }
    
    public function getStudentName() {
        return strtoupper($this->student->fullname);
    }
    
    public function getStudentInfo() {
        return strtoupper($this->student->fullname.'|'.$this->student->address.'|'.$this->student->gender);
    }
}

//$person = new Person();
$student = new Student(new Person('Tuan Nguyen', 'Tan Binh', 'Male'));

echo $student->getStudentInfo();
";i:1;s:3:"php";i:2;N;}i:2;i:2099;}i:76;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:3083;}i:77;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:38:"3. Three types of dependency injection";i:1;i:2;i:2;i:3083;}i:2;i:3083;}i:78;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:2;}i:2;i:3083;}i:79;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:3135;}i:80;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:25:"3.1 Constructor injection";i:1;i:3;i:2;i:3135;}i:2;i:3135;}i:81;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:3;}i:2;i:3135;}i:82;a:3:{i:0;s:4:"code";i:1;a:3:{i:0;s:356:"
class Book ()
{
    public function __construct($title, $author, $genre, $publishdate, $isbn)
    {
        $this->title = $title;
        $this->author = $author;
        $this->genre = $genre;
        $this->publishDate = $publishdate;
        $this->ISBN = $isbn;
    }
}
$book = new Book (new Title, new Author, new Genre, new PublishDate, new ISBN);
";i:1;s:3:"php";i:2;N;}i:2;i:3176;}i:83;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:3176;}i:84;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:70:"Các dependencies trên được tiêm thẳng vào hàm constructor. ";}i:2;i:3546;}i:85;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:3616;}i:86;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:3618;}i:87;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:20:"3.2 Setter injection";i:1;i:3;i:2;i:3618;}i:2;i:3618;}i:88;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:3;}i:2;i:3618;}i:89;a:3:{i:0;s:4:"code";i:1;a:3:{i:0;s:404:"
class Book ()
{
    public function __construct()
    {
    }

    public function setTitle($title)
    {
        $this->title = $title;
    }

...
// Here we have 4 more methods : setAuthor ,setGenre, setPublishDate, setISBN
}
...

$book = new Book;
$book->setTitle(new Title);
$book->setAuthor(new Author);
$book->setGenre(new Genre);
$book->setPublishDate(new PublishDate);
$book->setISBN(new ISBN);
";i:1;s:3:"php";i:2;N;}i:2;i:3655;}i:90;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:3655;}i:91;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:72:"các denpendencies được đưa vào class thôn qua các hàm setter.";}i:2;i:4073;}i:92;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:4145;}i:93;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:4145;}i:94;a:3:{i:0;s:6:"entity";i:1;a:1:{i:0;s:2:"->";}i:2;i:4147;}i:95;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:1:" ";}i:2;i:4149;}i:96;a:3:{i:0;s:14:"underline_open";i:1;a:0:{}i:2;i:4150;}i:97;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:22:"Vấn đề phát sinh";}i:2;i:4152;}i:98;a:3:{i:0;s:15:"underline_close";i:1;a:0:{}i:2;i:4174;}i:99;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:88:" : trường hợp có quá nhiều injection thì ta phải viết nhiều hàm setter.";}i:2;i:4176;}i:100;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:4264;}i:101;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:4264;}i:102;a:3:{i:0;s:14:"underline_open";i:1;a:0:{}i:2;i:4266;}i:103;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:30:"Phương pháp giải quyết-";}i:2;i:4268;}i:104;a:3:{i:0;s:15:"underline_close";i:1;a:0:{}i:2;i:4298;}i:105;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:85:": chúng ta sẽ đến với design pattern tiếp theo: Inversion of Control (IoC).";}i:2;i:4300;}i:106;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:4385;}i:107;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:4387;}i:108;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:26:"3.2.1 Inversion of Control";i:1;i:3;i:2;i:4387;}i:2;i:4387;}i:109;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:3;}i:2;i:4387;}i:110;a:3:{i:0;s:10:"quote_open";i:1;a:0:{}i:2;i:4424;}i:111;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:271:" In software engineering, inversion of control (IoC) is a programming technique, expressed here in terms of object-oriented programming, in which object coupling is bound at run time by an assembler object and is typically not known at compile time using static analysis.";}i:2;i:4426;}i:112;a:3:{i:0;s:11:"quote_close";i:1;a:0:{}i:2;i:4697;}i:113;a:3:{i:0;s:10:"quote_open";i:1;a:0:{}i:2;i:4698;}i:114;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:317:" Trong kỹ thuật phần mềm, Inversion of Control (IoC) là kỹ thuật lập trình hướng đối tượng nơi ghép các sự phụ thuộc vào các đối tượng tương ứng, được gọi ra bởi một assembler object và thường không được biết đến tại thời điểm biên dịch.";}i:2;i:4700;}i:115;a:3:{i:0;s:11:"quote_close";i:1;a:0:{}i:2;i:5017;}i:116;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:5017;}i:117;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:30:"Ta tạo 1 class IoC như sau:";}i:2;i:5019;}i:118;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:5055;}i:119;a:3:{i:0;s:4:"code";i:1;a:3:{i:0;s:589:"
class IoC {
   protected static $registry = array();

   // Register
   public static function register($name, Closure $resolve)
   {
      static::$registry[$name] = $resolve;
   }

   // Resolve
   public static function resolve($name)
   {
      if ( static::registered($name) )
      {
         $name = static::$registry[$name];
         return $name();
      }

      throw new Exception('Nothing registered with that name, fool.');
   }

   // Check resigtered or not
   public static function registered($name)
   {
      return array_key_exists($name, static::$registry);
   }

}
";i:1;s:3:"php";i:2;N;}i:2;i:5055;}i:120;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:5055;}i:121;a:3:{i:0;s:14:"underline_open";i:1;a:0:{}i:2;i:5657;}i:122;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:4:"Note";}i:2;i:5659;}i:123;a:3:{i:0;s:15:"underline_close";i:1;a:0:{}i:2;i:5663;}i:124;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:73:" : Class Closure là một anonymous function. Bạn có thể xem thêm ";}i:2;i:5665;}i:125;a:3:{i:0;s:12:"externallink";i:1;a:2:{i:0;s:42:"http://php.net/manual/en/class.closure.php";i:1;s:9:"ở đây";}i:2;i:5738;}i:126;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:5794;}i:127;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:5794;}i:128;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:58:"Bây giờ ta có thể khởi tạo class Book như sau :";}i:2;i:5796;}i:129;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:5854;}i:130;a:3:{i:0;s:4:"code";i:1;a:3:{i:0;s:287:"
IoC::register('book', function(){
    $book = new Book;
    $book->setTitle(new Title);
    $book->setAuthor(new Author);
    $book->setGenre(new Genre);
    $book->setPublishDate(new PublishDate);
    $book->setISBN(new ISBN);

    return $book;
});
...

$book = IoC::resolve('book');
";i:1;s:3:"php";i:2;N;}i:2;i:5861;}i:131;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:6162;}i:132;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:23:"3.3 Interface Injection";i:1;i:3;i:2;i:6162;}i:2;i:6162;}i:133;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:3;}i:2;i:6162;}i:134;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:6162;}i:135;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:84:"Ta dùng interface để set các service được sử dụng trong interface đó.";}i:2;i:6196;}i:136;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:6286;}i:137;a:3:{i:0;s:4:"code";i:1;a:3:{i:0;s:273:"
interface ServiceSetter {
    public function setService(Service $service);
}

class Client implements ServiceSetter {
    public function setService(Service $service) {
        $this->service = $service;
    }
}

$client = new Client();
$client->setService(new Service);
";i:1;s:3:"php";i:2;N;}i:2;i:6286;}i:138;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:6573;}i:139;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:33:"4. Laravel Dependencies Injection";i:1;i:2;i:2;i:6573;}i:2;i:6573;}i:140;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:2;}i:2;i:6573;}i:141;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:6619;}i:142;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:26:"4.1 Constructor injection:";i:1;i:3;i:2;i:6619;}i:2;i:6619;}i:143;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:3;}i:2;i:6619;}i:144;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:6619;}i:145;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:68:"Đưa các dependencies vào trong class thông qua hàm construct. ";}i:2;i:6656;}i:146;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:6724;}i:147;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:6724;}i:148;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:195:"Ví dụ: Ta tạo client controller có repository là ClientRepository qua hàm construct. (Một repository là một giao diện tương tác đơn giản giữa 2 đối tượng bất kì).";}i:2;i:6726;}i:149;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:6927;}i:150;a:3:{i:0;s:4:"code";i:1;a:3:{i:0;s:261:"
namespace App\Http\Controllers;
use App\Repositories\ClientRepository;
class ClientsController extends BaseController
{
    protected $repository;
    public function __construct(ClientRepository $repository) {
        $this->repository = $repository;
    }
}
";i:1;s:3:"php";i:2;N;}i:2;i:6927;}i:151;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:7202;}i:152;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:23:"4.2 Interface injection";i:1;i:3;i:2;i:7202;}i:2;i:7202;}i:153;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:3;}i:2;i:7202;}i:154;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:7202;}i:155;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:125:"Chúng ta có thể tạo 1 interface để mô tả các phương thức mà chúng ta mong đợi có trong interface đó.";}i:2;i:7236;}i:156;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:7367;}i:157;a:3:{i:0;s:4:"code";i:1;a:3:{i:0;s:212:"
namespace App\Contracts\Repositories;
interface ClientRepositoryInterface
{
    /**
     * @return \App\Contracts\DataProviders\BaseDataProviderInterface
     */
    public function getDataProvider();
    ...
}
";i:1;s:3:"php";i:2;N;}i:2;i:7367;}i:158;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:7367;}i:159;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:72:"Ta viết lại class Client Controller sử dụng interface injection:";}i:2;i:7593;}i:160;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:7671;}i:161;a:3:{i:0;s:4:"code";i:1;a:3:{i:0;s:289:"
namespace App\Http\Controllers;
use App\Contracts\Repositories\ClientRepositoryInterface;
class ClientsController extends BaseController
{
    protected $repository;
    public function __construct(ClientRepositoryInterface $repository) {
        $this->repository = $repository;
    }
}
";i:1;s:3:"php";i:2;N;}i:2;i:7671;}i:162;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:7671;}i:163;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:178:"Để tránh việc mập mờ khi sử dụng Interface, ta có thể đưa ra các chỉ dẫn thông qua các service providers. Ta tạo class ClientServiceProvider như sau:";}i:2;i:7974;}i:164;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:8158;}i:165;a:3:{i:0;s:4:"code";i:1;a:3:{i:0;s:368:"
namespace App\ServiceProviders\Resources;
use Illuminate\Support\ServiceProvider as LaravelServiceProvider;
class ClientServiceProvider extends LaravelServiceProvider
{
    public function register()
    {
        $this->app->bind(
            'App\Contracts\Repositories\ClientRepositoryInterface',
            'App\Repositories\ClientRepository'
        );
    }
}
";i:1;s:3:"php";i:2;N;}i:2;i:8158;}i:166;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:8158;}i:167;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:168:"Điều này có nghĩa là bất cứ khi nào tôi muốn dùng ClientRepositoryInterface, Laravel sẽ tự động biết rằng tôi muốn dùng ClientRepository.";}i:2;i:8540;}i:168;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:8708;}i:169;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:8708;}i:170;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:76:"Để dùng ClientServiceProvider ta sửa lại ClientsController như sau:";}i:2;i:8710;}i:171;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:8792;}i:172;a:3:{i:0;s:4:"code";i:1;a:3:{i:0;s:285:"
namespace App\Http\Controllers;
use App\ServiceProviders\Resources\ClientServiceProvider;
class ClientsController extends BaseController
{
    protected $repository;
    public function __construct(ClientServiceProvider $repository) {
        $this->repository = $repository;
    }
}
";i:1;s:3:"php";i:2;N;}i:2;i:8792;}i:173;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:9090;}i:174;a:3:{i:0;s:12:"document_end";i:1;a:0:{}i:2;i:9090;}}